{"posts":[{"title":"Maven学习笔记","text":"黑马程序员网课 Maven 学习笔记 目录 1. Maven 简介 1.1 依赖管理 1.2 项目构建 1.3 统一项目结构 2. Maven 坐标 3. Maven 依赖管理 4. Maven 的生命周期 5. Maven 单元测试 5.1 JUnit 断言 5.2 JUnit 常见注解 1. Maven 简介 Maven 是一个用于创建和管理 Java 项目的工具，其功能包括： 依赖管理 项目构建 统一项目结构 1.1 依赖管理 在 Maven 项目中，可通过修改 pom.xml 添加所需依赖，示例代码如下： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;!-- 依赖的组织/公司标识 --&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;!-- 依赖的项目/库名称 --&gt; &lt;version&gt;2.16.1&lt;/version&gt; &lt;!-- 依赖的版本号 --&gt; &lt;/dependency&gt;&lt;/dependencies&gt; POM 是项目对象模型（Project Object Model）的缩写。Maven 的仓库分为本地仓库、远程仓库（私服）和中央仓库（全球唯一，由 Maven 官方维护）。在 dependency 声明依赖后，系统会依次从本地仓库 —— 私服（如果有的话，一般是公司的服务器）—— 中央仓库搜索并下载。 1.2 项目构建 Maven 提供了跨平台的自动构建项目方法，在 IDEA 的 Lifecycle 中，可通过指令（如compile package）自动编译、打包 1.3 统一项目结构 在 IntelliJ IDEA 中可直接创建 Maven 项目，项目结构如下图： 其中 src 为主程序文件夹，其下的 java 文件夹存放 java 源代码，resources 文件夹存放依赖；test 文件夹存放测试程序；target 文件夹存放编译、打包出来的文件或临时文件；pom.xml 为核心配置文件 2. Maven 坐标 Maven 坐标是资源（jar 包）的唯一标识。下面是一个新创建的 Maven 项目的 pom.xml 文件： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; // Maven 坐标 &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven-project01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;25&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;25&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt;&lt;/project&gt; groupId：项目隶属的组织 artifactId：模块名/项目名称 version：版本号 在 verson 中，SNAPSHOT表示快照版本，即仍在开发中的版本；RELEASE表示正式发行的版本 3. Maven 依赖管理 引入依赖的方法： 在项目的 pom.xml 文件中引入 &lt;dependencies&gt; 标签 在 &lt;dependencies&gt; 标签下引入 &lt;dependency&gt;，补充 Maven 坐标信息；如果不知道具体的组织名 / 模块名称，可去 Maven 的中央仓库 https://mvnrepository.com/ 查询 点击刷新引入依赖 示例如下： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.1.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 排除依赖：在引入一些依赖时，所引入的依赖可能会带来一些本项目不需要的资源（jar 包），我们可以通过&lt;exclusions&gt;标签主动断开依赖 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.1.4&lt;/version&gt; {/* 排除依赖 */} &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.micrometer&lt;/groupId&gt; &lt;artifactId&gt;micrometer-observation&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意：依赖变更时，记得手动刷新 4. Maven 的生命周期 Maven 有三套相互独立的生命周期：clean, default, site clean: 清理上次编译、运行后的参与文件 default: 核心工作，负责编译、打包、部署等 site: 生成报告、发布站点等 五个重要的生命周期阶段：clean, compile, test, package, install 其中 clean 属于 clean 周期，其他四个属于 default 周期 clean: 移除上一次构建生成的文件 compile: 编译项目源代码 test: 使用合适的单元测试框架运行测试（JUnit） package: 将编译后的文件打包（jar, war） install: 将项目安装到本地仓库 注意：在同一套生命周期中，后面的操作执行时，一定执行前面的操作（如执行 install 时，compile一定执行） 5. Maven 单元测试 JUnit: Java 测试框架 单元测试的三步操作： 在 pom.xml 中，引入 JUnit 依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.9.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在 test/java 目录下，创建测试类，并编写对应的测试方法，并在方法上声明 @Test 注解 12345678910111213package com.itheima;import org.junit.jupiter.api.Test;public class UserServiceTest { @Test public void testGetAge(){ UserService userService = new UserService(); Integer age = userService.getAge(&quot;211231200409090198&quot;); System.out.println(age); }} 运行单元测试：绿色通过，红色未通过 注意：测试类的命名规范为：XxxxTest，测试方法的命名规定为：public void xxx(){…}，返回值必须为 void 类型 5.1 JUnit 断言 断言：判断程序输出的结果是否符合预期 常用的断言方法如下： 其中 exp 是预期的输出结果，act 是实际的输出结果，msg 是报错的提示信息 123456@Testpublic void getGenderTestWithAssert(){ UserService userService = new UserService(); String gender = userService.getGender(&quot;211231200409090215&quot;); Assertions.assertEquals(gender, &quot;男&quot;);} assertThrows用来判断程序抛出的异常和期望的异常是否一致，expType 是程序预期会抛出的异常，exec 是一个函数式接口，用于调用我们自己的方法，示例代码如下： 1234567@Testpublic void getGenderTestWithAssert2(){ UserService userService = new UserService(); Assertions.assertThrows(IllegalArgumentException.class, () -&gt; { userService.getGender(null); });} 5.2 JUnit 常见注解 注意：BeforeAll 和 AfterAll 只能用于静态（static）方法 ParameterizedTest 和 ValueSource 的使用方法如下： 12345678@DisplayName(&quot;测试用户性别&quot;) // 用于给测试类起别名@ParameterizedTest@ValueSource(strings = {&quot;211231200409090013&quot;, &quot;211231200409090053&quot;, &quot;211231200409090033&quot;})public void getGenderTest2(String idCard){ UserService userService = new UserService(); String gender = userService.getGender(idCard); Assertions.assertEquals(&quot;男&quot;, gender, &quot;性别错误&quot;);}","link":"/2025/12/03/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Ajax学习笔记","text":"黑马程序员网课 Ajax 学习笔记 #vue-table th, #vue-table td { text-align: center; } 目录 1. Ajax 简介 2. Ajax 请求案例 3. 异步变同步：async & await 4. Vue 的生命周期/钩子方法 1. Ajax 简介 Ajax 是一种异步通信方式，能够与服务器端交换数据 注：异步是指服务器端在处理浏览器发来的请求的过程中，浏览器页面可以继续做其他的操作；同步则是指服务器在处理请求时，浏览器只能等待服务器处理结束并返还数据后，才能继续做其他的操作 Axios 是一种简单的发送 Ajax 请求的技术 引入 Axios 的代码： 1&lt;srcipt src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/srcipt&gt; 下面是一段通过 Axios 向服务器端发送 GET / POST请求的代码： 123456789101112131415161718192021222324// GETdocument.querySelector(&quot;#btn1&quot;).addEventListener('click', () =&gt; { axios({ url: 'https://mock.apifox.cn/m1/3083103-0-default/emps/update', // 发送到服务器端的地址 method: &quot;GET&quot; // 使用 GET 方法 }).then((result) =&gt; { console.log(result) // 成功回调函数 }).catch((err) =&gt; { console.log(err) // 失败回调函数 })})// POSTdocument.querySelector(&quot;#btn1&quot;).addEventListener('click', () =&gt; { axios({ url: 'https://mock.apifox.cn/m1/3083103-0-default/emps/update', // 发送到服务器端的地址 method: &quot;POST&quot; // 使用 GET 方法 data: 'id=1' //请求体中携带的数据 }).then((result) =&gt; { console.log(result) // 成功回调函数 }).catch((err) =&gt; { console.log(err) // 失败回调函数 })}) 这里使用了 JS 中处理 click 交互的方法addEventListener，其中click表示用户的操作 成功回调函数：请求成功则执行；失败回调函数：请求失败时执行 axios 部分还可以简写如下： 12345678910111213// GETaxios.get('https://mock.apifox.cn/m1/3083103-0-default/emps/update').then((result) =&gt; { console.log(result)}).catch((err) =&gt; { console.log(err)})// POSTaxios.post('https://mock.apifox.cn/m1/3083103-0-default/emps/update', 'id=1').then((result) =&gt; { console.log(result)}).catch((err) =&gt; { console.log(err)}) 注：then().catch() 部分可简写为thenc，Vscode会自动弹出 2. Ajax 请求案例 1234567891011121314151617181920212223242526272829303132&lt;script type=&quot;module&quot;&gt; import {createApp} from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js' createApp({ data(){ return{ searchForm: { name: '', gender: '', job: '' }, empList: [] } }, methods: { search(){ axios.get(`https://web-server.itheima.net/emps/list?name=${this.searchForm.name}&amp;gender=${this.searchForm.gender}&amp;job=${this.searchForm.job}`).then((result) =&gt; { this.empList = result.data.data }).catch((err) =&gt; { alert(&quot;GET请求失败&quot;) }); }, clear(){ this.searchForm = { name: '', gender: '', job: '' } this.search() } } }).mount(&quot;#container&quot;)&lt;/script&gt; 在上段代码中，当前 Vue 实例的 search 方法和“查询”按钮相互绑定。当用户点击查询按钮时，search 方法被调用，向服务器发送请求。请求的内容为模板表达式中的内容，包含了 name, gender, job 等查询字段 值得注意的是this.empList = result.data.data，result 是服务器返回的对象，包含了 data, status, headers, statusText 等属性，其中result 和 result.data 内容如下： 而我们要获取的是其中的 data 字段，因此将当前实例下的 empList 赋值为 result.data.data 3. 异步变同步：async & await aysnc和await能够让异步操作变为同步操作，让代码从上到下按顺序执行，增强代码的可维护性 async用来声明异步操作，await用于让异步操作等待服务器端返回数据 123456789createApp({ data(){...}, methods: { async search(){ let result = await axios.get('target_url') // 无需成功回调函数 this.empList = result.data.data } }}).mount(&quot;#container&quot;) 4. Vue 的生命周期/钩子方法 Vue 有八个生命周期，如下表所示 阶段周期 状态/钩子方法 beforCreate 创建前 created 创建后 beforeMount 挂载前 mounted 挂载完成 beforUpdate 数据更新前 updated 数据更新后 beforeUnmount 组件销毁前 unmounted 组件销毁后 每触发一个生命周期时间，系统会自动执行对应的钩子方法，需要重点关注的是mounted mounted钩子方法在挂载完成后触发，可通过下面的代码在一开始就展示所有的数据： 123456789101112createApp({ data(){...}, methods: { async search(){ let res = awit axios.get('target_url') this.empList = res.data.data } }, mounted(){ this.search() }}).mount(&quot;#container&quot;) 注意：mounted方法要和data，methods在同一级别","link":"/2025/12/02/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"LaTeX笔记&#x2F;提纲模板","text":"自用的 LaTeX 模板 该模板基于四川大学智锐科创协会提供的 LaTeX 模板修改，适用于课堂笔记与提纲整理（如有侵权请联系作者，作者将立刻删除） note.tex文件内容如下，直接复制即可，在编译时使用 XeLaTeX 作为编译器 在note.tex同级的目录下，需要新建 figures 文件夹，并在文件夹中放上logo.png 最终呈现效果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153\\documentclass{article} % 核心宏包\\usepackage{ctex} \\usepackage{graphicx} \\usepackage{float} \\usepackage{amsmath} \\usepackage{tabularx} \\usepackage{booktabs} \\usepackage{fancyhdr} \\usepackage{geometry} \\usepackage{hyperref} % 字体设置% 使用标准Windows字体集\\ctexset{fontset = none}% 自定义宋体，支持伪斜体和伪粗体\\setCJKfamilyfont{zhsong}[ AutoFakeSlant = {0.3}, % 伪斜体，倾斜角度0.3 AutoFakeBold = {2.3} % 伪粗体，加粗程度2.3]{SimSun}\\renewcommand*{\\songti}{\\CJKfamily{zhsong}}% 定义楷体\\setCJKfamilyfont{zhkai}[AutoFakeBold = {2.3}]{KaiTi}\\newcommand{\\mykaiti}{\\CJKfamily{zhkai}}% 设置全局字体\\setCJKmainfont{SimSun}\\setCJKsansfont{SimHei}\\setCJKmonofont{FangSong}% 页面设置\\geometry{a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm}\\graphicspath{{figures/}} % 超链接设置\\hypersetup{ colorlinks=true, linkcolor=black, citecolor=blue}% 自定义命令\\newcommand{\\covertitle}{\\zihao{-0}\\heiti\\bfseries} \\newcommand{\\covertablename}{\\heiti \\zihao{-3}} \\newcommand{\\covertablecontent}{\\mykaiti \\zihao{-3}} \\newcommand\\covertable[2]{ \\begin{table}[H] \\centering \\begin{tabular}{p{12em}} {\\covertablename #1 }\\\\ \\end{tabular} \\begin{tabular}{p{14em}&lt;{\\centering}} {\\covertablecontent #2 }\\\\ \\hline \\end{tabular} \\end{table}}% 正文字体命令\\newcommand\\textFont{\\songti \\zihao{-4}}% 修改目录名称\\renewcommand{\\contentsname}{\\centerline{目录}} % 页眉设置\\pagestyle{fancy} \\fancypagestyle{页眉}{ \\fancyhead{} \\fancyhead[C]{你的名字} \\renewcommand\\headrulewidth{.5pt}}\\begin{document}% 封面区域\\quad \\\\ \\\\ % Logo\\begin{figure}[H] \\centering \\includegraphics[width=0.5\\linewidth]{logo}\\end{figure}\\quad \\\\ \\begin{center} \\covertitle{\\zihao{2}文章标题}\\end{center}\\quad \\\\ \\\\ \\\\% 封面信息表格\\covertable{作\\hskip 5em 者}{你的名字}\\covertable{提\\quad 交\\quad 日\\quad 期}{\\today}\\covertable{学\\hskip 5em 院}{xx学院}\\covertable{专\\hskip 5em 业}{xx专业}% 空白页结束\\thispagestyle{empty}\\newpage% 目录页\\thispagestyle{empty} % 目录页不显示页眉页脚% 生成目录\\tableofcontents\\newpage% 正文开始\\setcounter{page}{1}\\pagestyle{页眉}\\section{正文基础示例}\\textFont这是正文基础段落示例，LaTeX会自动完成排版对齐，无需手动调整格式。\\subsection{字体样式示例}可轻松实现 \\textbf{加粗文字}、\\emph{斜体文字}，或调整字号 {\\zihao{3} 大号文字}。\\textbf{伪粗体测试：这段文字应该显示为伪粗体效果。}\\emph{伪斜体测试：这段文字应该显示为伪斜体效果。}\\subsection{数学公式示例}行内公式：$E = mc^2$行间公式：$$ \\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi} $$\\subsection{表格示例}\\begin{table}[h!] \\centering \\caption{基础三线表示例} \\begin{tabularx}{0.9\\textwidth}{l X X} \\toprule \\textbf{维度} &amp; \\textbf{示例1} &amp; \\textbf{示例2} \\\\ \\midrule 内容1 &amp; 基础文本内容 &amp; 自动换行的长文本内容，无需手动调整宽度 \\\\ 内容2 &amp; 公式嵌入 &amp; $A = \\begin{bmatrix}1 &amp; 0 \\\\0 &amp; 1\\end{bmatrix}$ \\\\ \\bottomrule \\end{tabularx}\\end{table}\\section{结语}以上为LaTeX基础使用示例，可根据需求修改内容、样式及结构。{\\songti 宋体文本} {\\mykaiti 楷体文本} {\\heiti 黑体文本} \\end{document}","link":"/2026/01/07/LaTeX%E7%AC%94%E8%AE%B0-%E6%8F%90%E7%BA%B2%E6%A8%A1%E6%9D%BF/"},{"title":"Python创建虚拟环境","text":"整理了 Python 创建虚拟环境的几种方法 目录 1. 使用 venv 创建 1.1 venv 的安装和配置 2. 使用 uv 创建 2.1 uv 的安装和配置 2.2 uv 管理 python 版本 2.3 uv 管理虚拟环境 3. anaconda 环境管理 虚拟环境可以将不同项目所需的库隔离开，使其互不影响。本文将介绍几种创建虚拟环境的方法，所有的示例程序均在 Windows Subsystem for Linux 2（WSL 2）的 Ubuntu 20.04 发行版环境中运行。 1. 使用 venv 创建 1.1 venv 的安装和配置 基本语法： 1python -m venv 环境名称 环境名称通常命名为.venv。示例代码如下： 12345# 进入项目目录mkdir my_project &amp;&amp; cd my_project# 创建虚拟环境（命名为'.venv'是常见约定）python3 -m venv .venv 激活虚拟环境： 12345# Windows 系统.venv\\Scripts\\activate# Linux / MacOS 系统source .venv/bin/activate 激活后，命令行会显示环境名称：(.venv) $ 退出虚拟环境时，使用指令：deactivate即可 整个过程示例如下： 1234567891011121314151617181920212223242526272829(base) root@XiaoHei:/home/wanghaotian/TestCode# python -m venv .venv(base) root@XiaoHei:/home/wanghaotian/TestCode# source .venv/bin/activate(.venv) (base) root@XiaoHei:/home/wanghaotian/TestCode# pip install pandas==1.3.3 requests==2.26.0 Django==3.2.12# 安装过程略Successfully installed Django-3.2.12 asgiref-3.11.0 certifi-2025.11.12 charset-normalizer-2.0.12 idna-3.11 numpy-2.0.2 pandas-1.3.3 python-dateutil-2.9.0.post0 pytz-2025.2 requests-2.26.0 six-1.17.0 sqlparse-0.5.4 typing_extensions-4.15.0 urllib3-1.26.20(.venv) (base) root@XiaoHei:/home/wanghaotian/TestCode# pip listPackage Version------------------ -----------asgiref 3.11.0certifi 2025.11.12charset-normalizer 2.0.12Django 3.2.12idna 3.11numpy 2.0.2pandas 1.3.3pip 22.0.4python-dateutil 2.9.0.post0pytz 2025.2requests 2.26.0setuptools 58.1.0six 1.17.0sqlparse 0.5.4typing_extensions 4.15.0urllib3 1.26.20WARNING: You are using pip version 22.0.4; however, version 25.3 is available.You should consider upgrading via the '/home/wanghaotian/TestCode/.venv/bin/python -m pip install --upgrade pip' command.(.venv) (base) root@XiaoHei:/home/wanghaotian/TestCode# deactivate(base) root@XiaoHei:/home/wanghaotian/TestCode# pip show DjangoWARNING: Package(s) not found: Django # 没有找到包，可以看出虚拟环境实现了库的有效隔离 该部分参考了以下资源： 菜鸟教程：Python 虚拟环境的创建（venv） 2. 使用 uv 创建 2.1 uv 的安装和配置 uv 是一款由 Rust 编写的 Python 包管理器，相比于传统的 venv 更加高效快捷 uv 的安装： 12345# Linux / MacOScurl -LsSf https://astral.sh/uv/install.sh | sh# Windows powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot; 安装过程比较慢，需要耐心等待 12345678910111213# WindowsPS C:\\Windows\\system32&gt; powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;Downloading uv 0.9.17 (x86_64-pc-windows-msvc)Installing to C:\\Users\\15806\\.local\\bin uv.exe uvx.exe uvw.exeeverything's installed!To add C:\\Users\\15806\\.local\\bin to your PATH, either restart your shell or run: set Path=C:\\Users\\15806\\.local\\bin;%Path% (cmd) $env:Path = &quot;C:\\Users\\15806\\.local\\bin;$env:Path&quot; (powershell) 12345678910111213# Linux(base) root@XiaoHei:/home/wanghaotian/TestCode# curl -LsSf https://astral.sh/uv/install.sh | shdownloading uv 0.9.17 x86_64-unknown-linux-gnuno checksums to verifyinstalling to /root/.local/bin uv uvxeverything's installed!To add $HOME/.local/bin to your PATH, either restart your shell or run: source $HOME/.local/bin/env (sh, bash, zsh) source $HOME/.local/bin/env.fish (fish) 安装完成后，需要将 uv 配置到环境变量中去，并使用uv --version验证 1234567891011# 1. 编辑 root 用户的 bash 配置文件vim ~/.bashrc# 2. 在文件末尾添加以下内容：export PATH=&quot;$HOME/.local/bin:$PATH&quot;# 3. 刷新配置source ~/.bashrc# 4. 检查，出现类似于&quot;uv 0.9.17&quot;的提示即成功uv --version 2.2 uv 管理 python 版本 查看可用 python版本：uv python list 安装特定 python 版本：uv python install 3.12 设置全局默认 python 版本：uv python default 3.12 2.3 uv 管理虚拟环境 1234567891011121314# uv 创建名为 .venv 虚拟环境uv venv# 在 Windows 下激活环境.venv\\Scripts\\activate# 在 Linux 下激活环境source .venv/bin/activate# 为当前项目固定 Python 3.11 版本uv python pin 3.11# 安装某个特定版本的库uv pip install requests==2.31.0 该部分参考了以下资源： uv 中文文档 菜鸟教程：uv 入门教程 – Python 包与环境管理工具 3. anaconda 环境管理 anaconda 是最常用的环境管理工具之一，网络上有很多下载 anaconda 的教程，笔者在此不再过多赘述，仅给出几个常用的指令： 1234567891011# 创建环境conda create --name myenv python=3.8 # 激活环境conda activate myenv# 退出环境conda deactivate# 删除环境conda remove --name myenv --all 该部分参考了以下资源： 知乎：超全常用 conda 命令整理","link":"/2025/12/14/Python%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"},{"title":"Vue学习笔记-1","text":"黑马程序员网课 Vue 学习笔记 目录 1. 定义应用实例 2. Vue 常用指令 2.1 v-for 2.2 v-bind 2.3 v-if v-show 2.4 v-model 2.5 v-on 1. 定义应用实例 1234567891011121314151617&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; // 插值表达式，访问数据对象中的变量 &lt;/div&gt; &lt;script type=&quot;module&quot;&gt; // module表示模块化 JS 脚本，支持 import / export，这是能引入 Vue 库的前提 import {createApp} from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js' // 导入核心方法，详见 Vue 官方文档 https://cn.vuejs.org/guide/quick-start.html // 创建应用实例 createApp({ data(){ // 定义数据对象 return { message: &quot;Hello Vue&quot; }; } }).mount(&quot;#app&quot;) // 将 Vue 应用实例挂载到指定的 DOM 元素上 &lt;/script&gt;&lt;/body&gt; createApp 创建了一个应用实例，并通过 mount 方法将该实例挂在到 id=”app” 的 DOM 元素上，在上面的代码中即为 &lt;div id=&quot;app&quot;&gt; 挂载后，#app 元素内部的内容会被 Vue 模板替换（如果有原始内容会被覆盖） 2. Vue 常用指令 2.1 v-for 用途：循环渲染，要渲染哪个标签就把 v-for 写在该标签里 12345678910111213141516171819&lt;table&gt; &lt;thead&gt; ... &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(e, index) in empList&quot; :key=&quot;e.id&quot;&gt; &lt;td&gt;{{index + 1}}&lt;/td&gt; &lt;td&gt;{{e.name}}&lt;/td&gt; &lt;td&gt;{{e.gender == 1 ? '男' : '女'}}&lt;/td&gt; &lt;td&gt;{{e.job}}&lt;/td&gt; &lt;td&gt;{{e.entrydate}}&lt;/td&gt; &lt;td&gt;{{e.updatetime}}&lt;/td&gt; &lt;td class=&quot;action-buttons&quot;&gt; &lt;button type=&quot;button&quot;&gt;编辑&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; e 是列表 empList 里的元素，empList 定义如下： 12345678910111213141516171819202122232425createApp({ data(){ return{ empList: [ // 这里仿照了 JSON 文件的写法，模拟浏览器的数据传输 { &quot;id&quot;: 1, &quot;name&quot;: &quot;谢逊&quot;, &quot;gender&quot;: 1, &quot;job&quot;: 1, &quot;entrydate&quot;: &quot;2023-06-09&quot;, &quot;updatetime&quot;: &quot;2025-12-01T14:59:38&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;谢逊&quot;, &quot;gender&quot;: 1, &quot;job&quot;: 1, &quot;entrydate&quot;: &quot;2023-06-09&quot;, &quot;updatetime&quot;: &quot;2025-12-01T14:59:38&quot; }, ... ] } }}).mount(&quot;#container&quot;) 注意: Vue 实例中 data 数据对象的定义方式为：对象名: {..} 如果数据对象是数组，定义方式为：对象名: [{..}, {..}] :key 一般使用 id 作为唯一的键 2.2 v-bind 用途：用于动态绑定资源 1&lt;td&gt;&lt;img v-bind:src=&quot;e.image&quot; :alt=&quot;e.name&quot; style=&quot;width: 150px;&quot;&gt;&lt;/td&gt; v-bind:src 也可简写为 :src，在上述代码中用于动态绑定 image 资源（:alt 同理） 注意：在标签内部（如 img 标签&lt;img src=&quot;img1.png&quot; alt=&quot;img1&quot;&gt;）使用插值表达式会报错 2.3 v-if v-show 用途：都用于控制页面上元素显示与否；用&lt;span&gt;标签搭配控制元素 区别： v-if 只有条件为 true 才会渲染节点，v-show无论条件真假都会渲染节点，但会通过 css 样式控制是否显示该元素 v-show 适用于频繁切换显示隐藏的场景 12345678910111213141516&lt;td&gt; &lt;!-- v-if 控制--&gt; &lt;span v-if=&quot;e.job == 1&quot;&gt;班主任&lt;/span&gt; &lt;span v-else-if=&quot;e.job == 2&quot;&gt;讲师&lt;/span&gt; &lt;span v-else-if=&quot;e.job == 3&quot;&gt;学工主管&lt;/span&gt; &lt;span v-else-if=&quot;e.job == 4&quot;&gt;教研主管&lt;/span&gt; &lt;span v-else-if=&quot;e.job == 5&quot;&gt;咨询师&lt;/span&gt; &lt;span v-else&gt;其他&lt;/span&gt; &lt;!-- v-show 控制 --&gt; &lt;span v-show=&quot;e.job == 1&quot;&gt;班主任&lt;/span&gt; &lt;span v-show=&quot;e.job == 2&quot;&gt;讲师&lt;/span&gt; &lt;span v-show=&quot;e.job == 3&quot;&gt;学工主管&lt;/span&gt; &lt;span v-show=&quot;e.job == 4&quot;&gt;教研主管&lt;/span&gt; &lt;span v-show=&quot;e.job == 5&quot;&gt;咨询师&lt;/span&gt;&lt;/td&gt; 2.4 v-model 用途：双向绑定表单数据；在绑定前需要先在 data 里创建数据对象 12345678910111213141516&lt;form action=&quot;/search&quot; method=&quot;post&quot; class=&quot;search-form&quot;&gt; &lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; v-model=&quot;searchForm.name&quot; placeholder=&quot;请输入姓名&quot;&gt; &lt;!-- 和 searchFrom对象中的 name 成员双向绑定 --&gt;&lt;/form&gt;createApp({ data(){ return { searchForm: { name: '', gender: '', job: '' } } }}) 2.5 v-on 用途：绑定事件；语法为v-on:事件=&quot;方法&quot;，也可以简写为@事件=&quot;方法&quot; 12345678910111213141516171819202122&lt;div class=&quot;button-group&quot;&gt; &lt;button type=&quot;button&quot; v-on:click=&quot;search&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot; @click=&quot;clear&quot;&gt;清除&lt;/button&gt;&lt;/div&gt;createApp({ data(){ ... } methods: { search(){ console.log(this.searchForm) //这里必须用 this 指向当前实例的 data 对象 } clear(){ this.searchForm = { name: '', gender: '', job: '' } } }})","link":"/2025/12/02/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"},{"title":"Web后端基础","text":"黑马程序员网课 Web 基础学习笔记 1. 资源和架构 静态资源：服务器上存储的，不会改变的资源 动态资源：随用户请求的变化而变化的资源 B/S 架构：浏览器/服务器架构，如京东、12306等，应用逻辑和数据存放在服务器 C/S 架构：客户端/服务器架构，如 QQ 等，应用逻辑和数据存放在本地 2. Spring 框架 Spring：最流行的 Java 框架，其项目涵盖了各个应用场景 SpringBoot：快速开发 Web 项目，简化开发，提高效率 3. SpringBoot 入门 需求：基于SpringBoot的方式开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串 “Hello xxx ~” 创建好的 SpringBoot 项目结构如下： 这里已经删掉了不需要的项目结构，只保留了核心：src 文件夹和 pom.xml SpringbootWebQuickstartApplication是项目的启动类 / 引导类，其内容如下： 12345678910111213package com.itheima;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // 启动类的标识public class SpringbootWebQuickstartApplication { public static void main(String[] args) { SpringApplication.run(SpringbootWebQuickstartApplication.class, args); }} 里面是一个 main 函数，需要启动项目时直接运行这个 main 函数即可 resources/static 用于存放静态页面（html, css, JS） application.properties 是项目的核心配置文件 接下来编写请求处理类 HelloController，请求处理类一般以 Controller 结尾： 12345678910111213package com.itheima;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController // 表示这是一个请求处理类public class HelloController { @RequestMapping(&quot;/hello&quot;) // 指向请求路径 public String hello(String name){ System.out.println(&quot;name&quot; + name); return &quot;Hello&quot; + name + &quot;~&quot;; }} 注解： @RestController：当使用RestController注解一个类时，Spring会将该类视为控制器（Controller），并处理传入的HTTP请求 @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)：将 HTTP 请求映射到控制器方法 3.1 SpringBoot 入门程序剖析 构建入门程序时自动引入的依赖： springboot-starter-web：包含了 web 应用开发常用的依赖 springboot-starter-test：包含了单元测试常用的依赖 4. HTTP 协议 HTTP：超文本传输协议，规定了浏览器和服务器之间数据传输的规则 特点： 基于TCP协议: 面向连接，安全 基于请求-响应模型: 一次请求对应一次响应（先请求后响应） HTTP协议是无状态协议: 对于数据没有记忆能力。每次请求-响应都是独立的 无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。 缺点：多次请求间不能共享数据 优点: 速度快 4.1 HTTP 请求协议 GET 请求数据格式： POST 请求数据格式： POST 请求数据的请求头和请求体之间有一个空行 4.2 请求数据获取 Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装，封装为一个 HttpServletRequest 对象，并在调用Controller方法的时候传递给了该方法。这样就使得程序员不必直接对协议进行操作，让Web开发更加便捷 获取数据示例代码： 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima;import jakarta.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RequestController { @RequestMapping(&quot;/request&quot;) public String request(HttpServletRequest request){ // 1. 获取请求方式 - GET / POST String method = request.getMethod(); System.out.println(&quot;请求方式：&quot; + method); // 2. 获取请求 url 地址 String url = request.getRequestURL().toString(); System.out.println(&quot;url: &quot; + url); // http://localhost:8080/request String uri = request.getRequestURI(); System.out.println(&quot;uri: &quot; + uri); // /request // 3. 获取请求协议 String protocal = request.getProtocol(); System.out.println(&quot;请求协议：&quot; + protocal); // 4. 获取请求参数 - name, age String name = request.getParameter(&quot;name&quot;); System.out.println(&quot;name: &quot; + name); String age = request.getParameter(&quot;age&quot;); System.out.println(&quot;age: &quot; + age); // 5. 获取请求头 - Accept String header = request.getHeader(&quot;Accept&quot;); System.out.println(&quot;header: &quot; + header); return &quot;OK&quot;; }} 在浏览器输入：http://localhost:8080/request?name=wang&amp;age=21，控制台输出如下： 1234567请求方式：GETurl: http://localhost:8080/requesturi: /request请求协议：HTTP/1.1name: wangage: 21header: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 4.3 HTTP 响应协议 4.4 响应数据设置 Web服务器对HTTP协议的响应数据进行了封装(HttpServletResponse)，并在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让Web开发更加便捷 示例代码： 12345678910111213141516171819202122232425262728package com.itheima;import jakarta.servlet.http.HttpServletResponse;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.io.IOException;@RestControllerpublic class ResponseController { /** * 方式一 HttpServletResponse 设置响应数据 * @param response * @throws IOException */ @RequestMapping(&quot;/response&quot;) public void response(HttpServletResponse response) throws IOException { // 1. 设置响应状态码 response.setStatus(401); // 2. 设置响应头 response.setHeader(&quot;name&quot;, &quot;wang&quot;); // 3. 设置响应体 response.getWriter().write(&quot;&lt;h1&gt;hello response&lt;/h1&gt;&quot;); }} 在浏览器中输入http://localhost:8080/response，请求结果如下： Spring 中提供了 ResponseEntity，将请求结果封装为一个对象供程序员调用，示例如下: 12345678910/** * 方式二 ResponseEntity */@RequestMapping(&quot;/request2&quot;)public ResponseEntity&lt;String&gt; response2(){ return ResponseEntity .status(402) // 响应状态码 .header(&quot;name&quot;, &quot;javaweb&quot;) // 响应头 .body(&quot;&lt;h1&gt;hello java-web!&lt;/h1&gt;&quot;); // 响应体} 注：Java 泛型 public ResponseEntity&lt;String&gt; response2()这里使用了 Java 中泛型的语法。泛型的本质是类型参数化，把类型（比如 String、Integer、自定义类）当作 “参数” 传给类 / 方法 / 接口，让它们能适配多种类型，而不用写重复代码。定义类 / 方法时用占位符（如 T）代替具体类型，使用时再指定真实类型（如 String），核心解决 “代码冗余” 和 “类型不安全” 问题。 举个例子： 123456789101112131415161718192021// 泛型类：用&lt;T&gt;作为类型占位符（T是Type的缩写，也可以用E、K、V等）class Box&lt;T&gt; { private T content; // 成员变量的类型是T（占位符） // 方法参数/返回值的类型都是T public void put(T content) { this.content = content; } public T get() { return content; }}// 使用时：给&lt;T&gt;传入具体类型（这就是代码里&lt;String&gt;的本质）Box&lt;String&gt; strBox = new Box&lt;&gt;(); // 此时T=StringstrBox.put(&quot;hello&quot;);String str = strBox.get(); // 无需强制类型转换，安全Box&lt;Integer&gt; intBox = new Box&lt;&gt;(); // 此时T=IntegerintBox.put(123);Integer num = intBox.get(); // 类型安全，不会出错Box&lt;Double&gt; doubleBox = new Box&lt;&gt;(); // 还能适配Double，无需改Box类doubleBox.put(3.14);Double d = doubleBox.get();","link":"/2025/12/10/Web%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"title":"Vue学习笔记-2","text":"图灵学院 Vue 学习笔记 目录 1. 整体认识 Vue3 1.1 创建工程 1.2 项目结构 2. 理解：数据的双向绑定 3. OptionsAPI 和 CompositionAPI 4. Vue3 的数据双向绑定 5. 自定义组件 5.1 定义子组件 5.2 将子组件的对象暴露给父组件 5.3 将父组件的对象暴露给子组件 6. 组件的生命周期 7. Vue-Router 组件路由管理机制 1. 整体认识 Vue3 1.1 创建工程 12345# 创建工程npm create vue@latest # 启动项目npm installnpm run dev 1.2 项目结构 node_modules目录：存放依赖 public目录：静态资源，如图片视频等 src目录：放源代码 index.html：Vue 项目访问页面的入口 package.json文件：devDependencies ——依赖，scripts —— 启动脚本等 启动项目：npm run dev打包项目：npm run build 小结： 典型的 Vue 项目都只在 index 这一个页面里进行交互，即 SPA Vue3 的核心是通过 createApp 创建一个应用实例，在实例中构建各种应用 每一个 .vue 文件都是一个组件，组件可以互相嵌套 每个 vue 文件都包括 script, template, style 2. 理解：数据的双向绑定 理解：把 template 里的页面数据和 script 里的数据建立绑定关系 v-model 绑定数据v-on 绑定方法 Vue 单文件组件（SFC）的 &lt;template&gt; 要求只能有一个根节点 &lt;div&gt; 示例代码，注意 data 和 methods 的写法： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; 姓名：&lt;input v-model=&quot;userName&quot;&gt;{{ userName }}&lt;br&gt;&lt;br&gt; 薪水：&lt;input type=&quot;number&quot; v-model=&quot;salary&quot;&gt;{{ salary }}&lt;br&gt;&lt;br&gt; &lt;button @click=&quot;addSalary&quot;&gt;加薪&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;{/* lang=&quot;ts&quot; 声明该脚本块使用TypeScript编写 */}&lt;script lang=&quot;ts&quot;&gt; export default{ data(){ return { userName: &quot;roy&quot;, salary: 1800 } }, methods:{ addSalary(){ this.salary += 1000 } } }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; style 中的 scope 表示样式只在当前文件中生效 小结： 常用的双向绑定： v-if: 控制元素显示（直接摧毁） v-show：控制元素显示（通过 display） v-for: 循环显示元素 @方法: 将事件和方法绑定 在写 methods 时不要忘了 this 关键字 3. OptionsAPI 和 CompositionAPI OptionsAPI：配置式 API，用一个统一的对象封装所有代码逻辑 OptionsAPI 代码示例： 123456789101112131415161718192021222324252627&lt;script&gt; export default{ data(){ return{ userInfo: { name: &quot;&quot;, age: 0, gender: 1, job: &quot;&quot;, skills: [&quot;Java&quot;, &quot;Python&quot;, &quot;Vue&quot;] }, newSkill: &quot;&quot;, showUserInfo: false } }, methods: { learnNewSkill(){ if(this.newSkill){ this.userInfo.skills.push(this.newSkill) } }, changeShwoInfo(){ this.showUserInfo = !this.showUserInfo } } }&lt;/script&gt; CompositionAPI：组合式 API，把数据和方法写在一起 CompositionAPI 代码示例： 1234567891011121314&lt;script lang=&quot;ts&quot;&gt;import { ref } from 'vue'; export default{ setup(){ // 在进入页面时就调用这个函数 let userName = ref(&quot;joy&quot;) // ref 实现双向绑定 let salary = ref(1500) function addSalary(){ salary.value += 1000 } return {userName, salary, addSalary} // 把需要用的数据和方法返回 } }&lt;/script&gt; 可以通过 setup 的语法糖简化代码，在 script 中写 setup，就无需在代码中 setup 并 return 了 12345678&lt;script setup lang=&quot;ts&quot;&gt; import { ref } from 'vue'; let userName = ref(&quot;joy&quot;) let salary = ref(1500) function addSalary(){ salary.value += 1000 }&lt;/script&gt; 组合式 API 的另一个好处是可以在另一个文件里写逻辑，在 .vue 中直接调用即可 例如，在 components 文件夹下新建一个 MySalary.ts，内容如下： 12345678910import { ref } from &quot;vue&quot;;export default function(){ // 导出一个函数，执行并返回动态的值；而不是导出对象 let userName = ref(&quot;roy&quot;) let salary = ref(1500); function addSalary(){ salary.value += 1000 } return {userName, salary, addSalary}} 在 App.vue 中直接调用： 1234&lt;script setup lang=&quot;ts&quot;&gt; import MySalary from &quot;@/components/MySalary&quot; // @等价于 src 文件夹；自定义导出的匿名函数的名称为 Salary let {userName, salary, addSalary} = MySalary() // 解包对象&lt;/script&gt; 4. Vue3 的数据双向绑定 不要操作 ref 对象本身，而是操作它的 value 属性 让对象具备响应式的能力：reactive 1234567&lt;script setup lang=&quot;ts&quot;&gt;import { reactive } from 'vue'; let userInfo = reactive({userName: &quot;roy&quot;, salary: 15000}) function addSalary(){ userInfo.salary += 1000 }&lt;/script&gt; 注意：ref 包裹的数据需要通过 value 获取值，而 reactive 不需要 toRef() 可以把对象转成 ref 对象，使其具备响应式能力 toRefs(对象)：把这个对象的所有属性都转成 ref 对象 5. 自定义组件 5.1 定义子组件 在 components 文件夹下新建组件 SalaryInfo.vue，内容如下： 12345678910111213141516171819202122232425&lt;template&gt; 姓名：&lt;input type=&quot;text&quot; v-model=&quot;UserName&quot;/&gt;&lt;br /&gt; 工资：&lt;input type=&quot;number&quot; v-model=&quot;UserSalary&quot;/&gt; &lt;br /&gt; 加薪：&lt;input type=&quot;button&quot; @click=&quot;AddSalary&quot; value=&quot;点击&quot;&gt;&lt;/template&gt;&lt;!-- 这部分是为了暴露组件，自定义名称为&quot;SalaryInfo&quot; --&gt;&lt;script lang=&quot;ts&quot;&gt; export default{ name: &quot;SalaryInfo&quot; }&lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt; import { ref } from 'vue'; let UserName = ref(&quot;roy&quot;) let UserSalary = ref(15000) function AddSalary(){ UserSalary.value += 1000 } &lt;/script&gt;&lt;style&gt;&lt;/style&gt; 定义好之后，在 App.vue 中引入组件： 123456789101112131415&lt;template&gt;&lt;div&gt; &lt;!-- 在这里引入组件 --&gt; &lt;SalaryInfo&gt;&lt;/SalaryInfo&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import SalaryInfo from './components/SalaryInfo.vue';&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 5.2 将子组件的对象暴露给父组件 在父组件中我们可以获取子组件的一些属性。在此之前，需要让子组件先暴露给父组件：在 SalaryInfo.vue 中作出如下修改： 12345678910&lt;script setup lang=&quot;ts&quot;&gt; import { ref } from 'vue'; let userName = ref(&quot;roy&quot;) let userSalary = ref(15000) function AddSalary(){ userSalary.value += 1000 } // 添加以下代码，暴露出父组件需要的部分 defineExpose({userName, userSalary, AddSalary}) &lt;/script&gt; App.vue 修改如下： 12345678910111213141516171819&lt;template&gt;&lt;div&gt; &lt;SalaryInfo ref=&quot;salaryInfo&quot;&gt;&lt;/SalaryInfo&gt; &lt;button @click=&quot;showRes&quot;&gt;查看薪水信息&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import { ref } from 'vue';import SalaryInfo from './components/SalaryInfo.vue';let salaryInfo = ref();function showRes(){ console.log(salaryInfo)}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; &lt;SalaryInfo ref=&quot;salaryInfo&quot;&gt;&lt;/SalaryInfo&gt;：ref 在 Vue 中用来获取 DOM 元素或子组件实例的引用。Vue 会自动将该子组件的实例对象挂载到 &lt;script setup&gt; 中同名的 ref 变量上。在这里是let salaryInfo = ref();。此处已经获取到子组件，通过 console.log 在控制台打印信息 5.3 将父组件的对象暴露给子组件 修改后的代码如下，下面将作详细说明： SalaryInfo.vue 123456789101112131415161718192021&lt;template&gt; 姓名：&lt;input type=&quot;text&quot; v-model=&quot;salaryInfo.userName&quot;/&gt;&lt;br /&gt; 工资：&lt;input type=&quot;number&quot; v-model=&quot;salaryInfo.userSalary&quot;/&gt; &lt;br /&gt; &lt;!-- 加薪：&lt;input type=&quot;button&quot; @click=&quot;AddSalary&quot; value=&quot;点击&quot;&gt; --&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; export default{ name: &quot;SalaryInfo&quot; }&lt;/script&gt;&lt;script setup lang=&quot;ts&quot;&gt; defineProps([ &quot;salaryInfo&quot; ])&lt;/script&gt;&lt;style&gt;&lt;/style&gt; App.vue 12345678910111213141516171819202122&lt;template&gt;&lt;div&gt; &lt;SalaryInfo :salary-info=&quot;salaryInfo&quot;&gt;&lt;/SalaryInfo&gt; &lt;button @click=&quot;showRes&quot;&gt;查看薪水信息&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import { reactive } from 'vue'import SalaryInfo from './components/SalaryInfo.vue';let salaryInfo = reactive({ userName: &quot;roy&quot;, userSalary: 15000})function showRes(){ salaryInfo.userSalary += 1000}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在 SalaryInfo.vue 中，通过defineProps接收来自父组件暴露的数据，接受的是一个列表，列表中的元素是暴露的数据的名字，即salaryInfo。&lt;input type=&quot;text&quot; v-model=&quot;salaryInfo.userName&quot;/&gt;中获取的 userName 就来源于它（这里并没有对获取的数据做校验，也就是说不能保证获取到的 salaryInfo 对象一定有 userName 属性，这里可能会报错）。 在 App.vue 中，&lt;SalaryInfo :salary-info=&quot;salaryInfo&quot;&gt;&lt;/SalaryInfo&gt;中的:是 v-bind 的简写，用于双向绑定动态资源；:salary-info中的 salary-info 是子组件接收的 Prop 名称，也就是父组件向外暴露的名称。在 Vue 的处理过程中，会把 salary-info 转为 salaryInfo，也就是子组件中要接收的数据的名字。最后的salaryInfo是数据源的名称，对应着 123let salaryInfo = reactive({ userName: &quot;roy&quot;, userSalary: 15000}) 6. 组件的生命周期 生命周期分为四个阶段：创建 挂载 更新 销毁（卸载） CompositionAPI 的生命周期阶段： 创建阶段：setup 挂载阶段：onBeforeMount onMounted 更新阶段：onBeforeUpdate onUpdated 卸载阶段：onBeforeUnmount onUnmounted 用法如下： 123456&lt;script setup lang=&quot;ts&quot;&gt;import { onMounted } from 'vue'onMounted(()=&gt;{ console.log(&quot;挂载后&quot;)})&lt;/script&gt; 7. Vue-Router 组件路由管理机制 路由：实现在页面上点击跳转 安装 Vue-Router：npm install vue-router@4（也可以在创建项目时就把 vue-router 选上） App.vue 内容如下，目标是通过点击“首页”、“关于”、“新闻”实现跳转： 123456789101112131415161718192021222324252627&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;&quot;&gt;关于&lt;/a&gt; &lt;a href=&quot;&quot;&gt;新闻&lt;/a&gt; &lt;/p&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; a { margin-right: 10px; color: green; } .container { background-color: yellowgreen; widows: 10%; height: 400px; }&lt;/style&gt; 首先需要在 src/pages 文件夹下创建三个页面对应的组件：HomePage.vue, AboutPage.vue, NewsPage.vue 在 main.ts 中实现路由逻辑。一共分为三步：配置路由规则、创建路由器、加载路由器 12345678910111213141516171819202122232425import { createApp } from 'vue'import App from './App.vue'import HomePage from './pages/HomePage.vue'import AboutPage from './pages/AboutPage.vue'import NewsPage from './pages/NewsPage.vue'import {createRouter, createWebHistory} from 'vue-router'// 1. 配置路由规则// 创建路由数组 path: 路径 component: 需要跳转到的页面组件 name：路由的别名const routes = [ {path: &quot;/home&quot;, component: HomePage, name: &quot;home&quot;}, {path: &quot;/about&quot;, component: AboutPage, name: &quot;about&quot;}, {path: &quot;/news&quot;, component: NewsPage, name: &quot;news&quot;}]// 2. 创建路由器const router = createRouter({ history: createWebHistory(), // 路由工作模式 routes: routes // 路由规则})// 3. 加载路由器const app = createApp(App)app.use(router)app.mount('#app') 完成路由配置后，我们回头修改 App.vue 组件。实现路由跳转需要两个标签：&lt;RouterLink&gt; 和 &lt;RouterView&gt; 其中 &lt;RouterLink&gt; 描述跳转到哪个页面，&lt;RouterView&gt; 确定路由的出口，即跳转的内容渲染到哪里 App.vue 如下： 123456789101112131415161718192021222324252627&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;RouterLink to=&quot;/home&quot;&gt;首页&lt;/RouterLink&gt; &lt;!--字符串跳转--&gt; &lt;RouterLink :to=&quot;{path: '/about'}&quot;&gt;关于&lt;/RouterLink&gt; &lt;!--对象跳转--&gt; &lt;RouterLink :to=&quot;{name: 'news'}&quot;&gt;新闻&lt;/RouterLink&gt; &lt;!--具名跳转--&gt; &lt;/p&gt; &lt;div class=&quot;container&quot;&gt; &lt;RouterView /&gt; &lt;!--路由出口--&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; a { margin-right: 10px; color: green; } .container { background-color: yellowgreen; widows: 10%; height: 400px; }&lt;/style&gt; 上面代码中的 RouterLink 分别通过三种跳转方法实现路由跳转，其中对象跳转和具名跳转通过 json 形式包裹对象 RouterLink 中有一个属性 replace，使用方法如下 &lt;RouterLink replace :to=&quot;{name: 'news'}&quot;&gt;新闻&lt;/RouterLink&gt; 加上 replace 属性后，浏览器访问时不能回退","link":"/2025/12/11/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"},{"title":"空白的梦中之梦——读《楚王梦雨》之后","text":"张枣的诗作 .blue-card { background: #e3f2fd; /* border-left: 4px solid #2196f3; */ padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0，0，0，.05); margin-bottom: 24px; width: 100%; } .poem { text-align: left; margin: auto; padding: 0 0 0 35%; font-family: \"KaiTi\", \"楷体\", serif; font-size: 20px; } 诗人简介 张枣（1962年12月29日—2010年3月8日），湖南长沙人，中国现代诗人，中国先锋诗歌的代表人之一，1984年秋，不到二十二岁的张枣即以《镜中》闻名大江南北。张枣以“后赫耳墨斯学派（Posthermetische Schule）”闻名于世，被认为一方面给世界文学添加了创新的元素，另一方面又在作品中保留了中国古诗词的特点。（来源于维基百科） 楚王梦雨 我要衔接过去一个人的梦， 纷纷雨滴同享的一朵闲云； 我的心儿要跳得同样迷乱， 宫殿春叶般生，酒沫鱼样跃， 让那个对饮的，也举落我的手。 我的手扪脉，空亭吐纳云雾， 我的梦正梦见另一个梦呢。 枯木上的灵芝，水腰系上绢帛， 西边的飞蛾探听夕照的虚实。 它们刚辞别幽所，必定见过 那个一直轻呼我名字的人， 那个可能鸣翔，也可能开落， 给人佩玉，又叫人狐疑的空址。 她的践约可能是澌澌潮湿的。 真奇怪，雨滴还未发落的前夕， 我已感到了周身潮湿呢： 青翠的竹子可以拧出水， 山谷来的风吹入它们的内心， 而我的耳朵似乎飞到了半空， 或者是凝伫了而燃烧吧，燃烧那个 一直戏睡在里面，那湫隘的人。 还燃烧她的耳朵，烧成灰烟， 决不叫她偷听我心的饥饿。 你看，这醉我的世界含满了酒， 竹子也含了晨曦和岁月。 它们萧萧的声音多痛，多痛， 愈痛我愈要剥它，剥成七孔， 那么我的痛也是世界的痛。 请你不要再聆听我了，莫名的人。 我知道你在某处，隔风嬉戏。 空白的梦中之梦，假的荷叶， 令我彻夜难眠的住址。 如果雨滴有你，火焰岂不是我？ 人神道殊，而殊途同归， 我要，我要，爱上你神的热泪。 1987.6.12 威茨堡大学 《楚王梦雨》是诗人张枣写于1987年的诗作。整首诗脱胎于楚襄王梦神女的神话，以楚王的视角描述这空幻、诡谲的“梦中之梦”。纳博科夫言：“虽然读书时用的是脑，可真正领略艺术带来的欣悦的部位却在两块肩胛骨之间，可以相当肯定的说，那脊背的微微震颤是人类发展纯艺术、纯科学的过程中，所达到的最高情感宣泄的形式，让我们崇拜自己的脊椎和脊椎的兴奋吧”[1]。张枣的诗作似有异曲同工之妙：大量的留白，跳跃的思绪，场景、人称、时空的不停切换，共同搭建起一座“诗迷宫”，读罢只觉意犹未尽，情绪的起伏竟优先于文本的解读。即便如此，笔者仍试图在草蛇灰线中寻找更一个更清晰的脉络，遂写下对此诗的个人解读。 “我要衔接过去一个人的梦/纷纷雨滴同享的一朵闲云”。对梦境的解答须追溯到战国时期的辞赋家宋玉的《高唐赋》《神女赋》。《高唐赋》通过宋玉和楚顷襄王的对话描绘了登临高唐观的美景：“惟高唐之大体兮，殊无物类之可仪比”。楚顷襄王和宋玉登上高唐观，极目远眺，只见高唐观上出现了奇异的云气。宋玉于是向楚王讲述了先王游猎高唐，梦遇神女，与其同寝的故事。神女“旦为朝云，暮为行雨”，变化无穷。《神女赋》写于宋玉的晚年，回忆了青年时和楚顷襄王的问答。楚顷襄王就寝时于神女相遇，感叹神女的美貌，却因未能与神女云雨而忧伤，“惆怅垂涕，求之至曙”。在这样的背景下，诗人将现代语言和古典诗意巧妙融合，延续了“化欧化古”的写作风格。 诗歌的第一小节简要交代了背景，“过去一个人”指代的便是宋玉所说的“先王”。这一节的技巧值得玩味：“纷纷雨滴同享一朵闲云”，自然景观和楚顷襄王与先王的共享梦境，构成了巧妙的对仗。雨是神女的化身（“暮为行雨”），淋湿了整个梦境。神女若隐若现，楚顷襄王的对饮者是谁？亭子为什么是空的？神女的化身已经出现，真人却像隐在梦境之外，虚实相生。楚王的梦和先王的梦互相嵌套，虚幻的梦境便开始了。 接下来的两节都在为神女的出现造势：“轻呼我名字的人”给出的空址，雨滴还未发落便周身潮湿的楚王。这里第一次出现了火的意象：楚王的耳朵飞到半空，凝伫而燃烧。这个情景非常超现实主义（毕竟是在梦里），让人想起《人类之子》里飞到半空的苹果。水火不容，火焰的出现制造了紧张与对立，一端是楚王，一端是神女。“我心的饥饿”可能代表着楚王两个层面的欲望。第一是对治理天下的欲望：《高唐赋》中写：“王将欲往见，必先斋戒。差时择日，简舆玄服。建云旆，蜺为旌，翠为盖。风起雨止，千里而逝。盖发蒙，往自会。思万方，忧国害。开贤圣，辅不逮。九窍通郁精神察，延年益寿千万岁。”君王与神女相会，可以启发蒙昧，成为圣明之君。第二是对个人的欲望：“褰余帷而请御兮，愿尽心之惓惓。怀贞亮之洁清兮，卒与我兮相难”；“情独私怀，谁者可语？惆怅垂涕，求之至曙”（《神女赋》）。欲望尚未得到满足，他的心便是饥饿的。这种饥饿随即转化为痛苦：我的痛便是世界的痛。这两节诗在情感上层层递进，从最初的期盼，到“心的饥饿”，再到痛苦，在超现实的场景中完成了转换。 这种痛苦同样是诗人情感的折射。1986年，张枣赴德国读书。他用“孤悬”一词形容自己当时的处境：“我在海外是极端不幸福的，试想想孤悬在这儿有哪点好？”精神上他同样寂寞：“住在德国，生活是枯燥的，尤其到了冬末，静雪覆路，室内映着虚白的光，人会萌生‘红泥小火炉，……能饮一杯无？’的怀想。但就是没有对饮的那个人。……是的，在这个时代，连失眠都是枯燥的，因为没有令人心跳的愿景。……于是，趁着夜深人静，再独自闲饮。这时，内心一定很空惘，身子枯坐在一个角落里，只顾早点浸染上睡意，了却这一天。”[2]在《卡夫卡致菲丽斯》中，诗人发出血一般的呐喊：“夜啊，你总是还够不上夜/孤独，你总是还不够孤独！”这样的孤独让作者难以忍受，那个等待着对饮者现身，空虚痛苦的楚王，便是作者的情感投影。 隔空嬉戏而不肯现身的神女，虚幻的梦中之梦，空等的楚王，整首诗的情绪在最后一节终于迎来悄无声息的隐退和爆发式的高潮。楚王得到了寻人不遇的答案：人神道殊。人和神的交流本就是偶然，注定走上不同的道路，如同雨滴和火焰本不能共存。对于这种必然的错过和遗憾，作者借楚王发出了自己的声音：“我要，我要，爱上你神的热泪”。整首诗的情绪在这里达到顶峰，并戛然而止，留下了爆炸般的回响。面对无可抵达的彼岸，仰望或许是合理而无奈的答案。楚王无法接近的神女，诗人无法离开的孤独，在文本内外巧妙应和，余音绕梁。 注释和参考文献： 1. 纳博科夫《文学讲稿》（2005年版本）第53页 2. 《众声》诗人张枣：拥有天赋，不堪孤独，郭玉洁，人民文学出版社。网络链接：https://m.thepaper.cn/baijiahao_17260137","link":"/2025/12/08/%E7%A9%BA%E7%99%BD%E7%9A%84%E6%A2%A6%E4%B8%AD%E4%B9%8B%E6%A2%A6%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E6%A5%9A%E7%8E%8B%E6%A2%A6%E9%9B%A8%E3%80%8B%E4%B9%8B%E5%90%8E/"},{"title":"uv环境管理简明教程","text":"总结 uv 的使用方法和常用指令 目录 1. 初始化项目 2. 创建虚拟环境 3. 运行程序 4. 复现 uv 环境 uv 是一款基于 Rust 编写的 Python 环境管理工具，本文将总结 uv 的使用方法和常用指令[1]。uv 在 Windows 和 Linux / MacOS 系统下的安装详见笔记”Python创建虚拟环境”。本文的所有示例程序均在 Windows Subsystem for Linux 2（WSL 2）的 Ubuntu 20.04 发行版环境中运行。 1. 初始化项目 在项目文件夹中运行uv init指令即可完成初始化，运行后的项目结构如下： 1234567.├── .git├── .gitignore # 版本管理├── .python-version # python 版本说明├── README.md # 说明文档├── main.py # 主程序入口└── pyproject.toml # 配置文件信息 其中 pyproject.toml 内容如下： 1234567[project]name = &quot;uvtest&quot; # 项目名称version = &quot;0.1.0&quot; # 项目版本号description = &quot;Add your description here&quot; # 项目介绍readme = &quot;README.md&quot; # 说明文档requires-python = &quot;&gt;=3.9&quot; # python 版本要求dependencies = [] # 依赖 2. 创建虚拟环境 通过uv venv指令即可创建环境。根据提示，可通过source .venv/bin/activate激活环境。实际上 uv 会首先查找当前项目下有无 .venv 文件夹，无需手动激活也能够正常使用。 1234(base) root@XiaoHei:/mnt/d/UvTest# uv venvUsing CPython 3.9.12 interpreter at: /root/anaconda3/bin/python3Creating virtual environment at: .venvActivate with: source .venv/bin/activate 通常情况下，直接使用uv venv创建环境会很慢。一个常用的提速方法是配置镜像源[2]： Linux / macOS：创建并编辑 /etc/uv/uv.toml 或者 $XDG_CONFIG_DIRS/uv/uv.toml Windows：创建并编辑 %SYSTEMDRIVE%\\ProgramData\\uv\\uv.toml uv.toml内容为：python-install-mirror = &quot;https://registry.npmmirror.com/-/binary/python-build-standalone/&quot; 在项目中生成的配置文件 pyproject.toml 中添加以下内容： 12[tool.uv]python-install-mirror = &quot;https://registry.npmmirror.com/-/binary/python-build-standalone/&quot; 3. 运行程序 使用uv run main.py运行程序，运行时所有依赖的版本会自动更新 通过uv add pandas numpy添加依赖 123(UvTest) (base) root@XiaoHei:/mnt/d/UvTest# uv add numpy --default-index https://pypi.tuna.tsinghua.edu.cn/simpleResolved 4 packages in 782ms Audited 1 package in 4ms 在实际下载的过程中，和 pip 一样，如果不使用国内的镜像源直接下载，uv 将从中央仓库拉取依赖，下载速度非常之慢。配置国内源的方法有两种，一种是直接在指令后加参数（如上面的示例代码）[3]： 1uv add numpy --default-index https://pypi.tuna.tsinghua.edu.cn/simple 另一种是永久性的配置镜像源： 1234# 清华源echo 'export UV_DEFAULT_INDEX=&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;'&gt;&gt; ~/.bashrc# 令配置立刻生效source ~/.bashrc 依赖下载完成后，可以发现配置文件 pyproject.toml 发生了变化： 1234567891011121314[project]name = &quot;uvtest&quot;version = &quot;0.1.0&quot;description = &quot;Add your description here&quot;readme = &quot;README.md&quot;requires-python = &quot;&gt;=3.9&quot;dependencies = [ &quot;numpy&gt;=2.0.2&quot;, &quot;pandas&gt;=2.3.3&quot;,][[tool.uv.index]]url = &quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;default = true 还可以安装特定版本的库，如uv add matplotlib==3.9.4 移除库时，使用指令uv remove matplotlib 注意：在使用 uv 时，应尽可能避免使用 pip，以免造成环境污染 通过 uv.lock 文件可严格锁定依赖的版本，避免版本冲突 通过uv tree可以清晰地看到项目的依赖关系树： 123456789101112131415161718192021222324(base) root@XiaoHei:/mnt/d/UvTest# uv treeResolved 24 packages in 9msuvtest v0.1.0├── matplotlib v3.9.4│ ├── contourpy v1.3.0│ │ └── numpy v2.0.2│ ├── cycler v0.12.1│ ├── fonttools v4.60.2│ ├── importlib-resources v6.5.2│ │ └── zipp v3.23.0│ ├── kiwisolver v1.4.7│ ├── numpy v2.0.2│ ├── packaging v25.0│ ├── pillow v11.3.0│ ├── pyparsing v3.2.5│ └── python-dateutil v2.9.0.post0│ └── six v1.17.0├── numpy v2.0.2└── pandas v2.3.3 ├── numpy v2.0.2 ├── python-dateutil v2.9.0.post0 (*) ├── pytz v2025.2 └── tzdata v2025.3(*) Package tree already displayed 4. 复现 uv 环境 首先移除现有的虚拟环境：rm -rf .venv 复现环境时必须有 pyproject.toml 和 uv.lock 两个文件 只需uv sync即可实现复现 此外，还可以通过uv add -r requirements添加依赖 本文参考了以下资源： [1] bilibili：全面掌握UV：Python下一代环境管理懒人工具（Python五分钟）[2] CSDN：uv下载python加速镜像源 uv python下载加速配置文件 全局配置 项目配置[3] 知乎：别再忍了！uv 下载慢如龟速？一招配置国内镜像，让你的 Python 体验坐上火箭！","link":"/2025/12/14/uv%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"},{"title":"诗与歌——以《镜中》为例浅谈诗歌的“语气”","text":"笔者大二时《中华文化》的课程作业 .orange-card { background: #fff3e0; border-left: 4px solid #ff9800; padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0，0，0，.05); margin-bottom: 24px; width: 100%; } .blue-card { background: #e3f2fd; /* border-left: 4px solid #2196f3; */ padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0，0，0，.05); margin-bottom: 24px; width: 100%; } .poem { text-align: left; margin: auto; padding: 0 0 0 35% ; } 这篇文章是笔者大二时《中华文化》的课程作业，于 2024.5.16 完成。自从上大学之后很少主动写过这样的文字，故将其作为本站的第一篇博客，以此纪念。 摘要 本文从新诗的发展开始，阐述了新月派“音乐性”的提出以及对中国新诗的影响，并进一步解释了何为诗歌的“语气”，最后以张枣《镜中》为例进行了简要的分析 关键词：新诗 新月派 音乐性 语气 1917年2月，《新青年》刊登出胡适的《白话诗八首》，标志着中国新诗的诞生。在古典诗歌的创作逐渐走向僵化，意象逐渐腐朽，腔调逐渐统一的近代，新诗的到来无疑为中国诗坛注入了巨大的能量。新诗在形式上打破了字数和句式的限制，冲出了韵脚的束缚，在内容上显示其现代性，着重于书写人的内心感受，生活状态以及社会现状等，极大地丰富了可供选择的题材。与此同时，新诗的流派百花齐放，其中湖畔派，新月派，象征派等对后续的诗歌创作产生了导向性的影响。以新月派为例，他们不满于五四以后自由诗人忽视诗艺的作风，提倡新格律诗，主张“理性节制情感”的美学原则与诗歌形式的格律化，为了实现这一理论原则，以闻一多为代表的新月派诗人在诗歌艺术上做了有益的尝试。闻一多在著作《诗的格律》中提出了著名的“三美”主张，即“音乐美”“绘画美”“建筑美”。本文将从诗歌的“音乐美”着手，探讨现代诗歌中的韵律，节奏等问题。 包括语言的声、韵、调等文字乐感元素，语言的气势、顿歇、色彩、神韵等情绪内涵，词语的选择、语言的组织，语义的关联、声音的修辞等声音的表现技术，新诗的声音是现代汉语综合作用于人们感官的有意味的诗性艺术。传统诗歌的可歌性应该是诗歌的一个基本属性，后来歌与诗开始分离，可歌之诗谓之歌诗(乐歌)，不歌之诗称为诵诗(徒诗)，二者互为影响，诗与歌既分离，又结合，诗始终没有脱离可歌性。传统诗歌的歌性特征在新诗变革中发生了现代性转变[1]。新诗的变革尝试将诗歌从韵律中解放出来:“诗自诗，而歌自歌，歌如歌谣，乐府词曲，或为情感的言语之复写，或不能离乐谱而独立，都是可以唱的;而诗则不必然[2]。郭沫若主张“诗”“歌”分离，将诗从歌的枷锁中解脱出来。自由地书写是白话诗人从审美和精神两个层面上的主张，虽然要在一定程度上放弃形式上的美，但书写及表达的自由又会在精神的维度上重新赋予其美感。诗其所诗，歌其所歌，“从心所欲，不逾矩”地表达是现代诗人普遍追求的境界。 但并非甩脱了韵脚，现代诗就会变得自由。韵脚，求其根源是诗歌“语气”的一种存在形式。这里所说的诗歌的“语气”可以理解为一种内在的，属于诗歌本身的声音。从这个角度看，与其说是诗人创造了诗歌，不如说是诗歌在引领着诗人，通过诗人的喉咙发声，按着诗人的笔书写，而诗人只是诗歌表达的媒介。 诗的语气，不仅取决于文字的节奏，声带的震动，还取决于“诗意”。诗意是诗人用语言和情感所形成的意味、意涵、意境。人们通常更愿意理解为是优美的语言和动人的情感[3]。这些情感的表达又受制于写诗的技艺和使用的意象。以张枣的《镜中》为例： 只要想起一生中后悔的事 梅花便落了下来 比如看她游泳到河的另一岸 比如登上一株松木梯子 危险的事固然美丽 不如看她骑马归来 面颊温暖 羞惭。低下头，回答着皇帝 一面镜子永远等候她 让她坐到镜中常坐的地方 望着窗外，只要想起一生中后悔的事 梅花便落满了南山 这首诗很短，是张枣的代表作品之一，也是张枣“化欧化古”的杰作。梅花、河、松木梯子、骑马的女子、皇帝、镜子、南山等意象流淌着古意，只需单看这些意象，也好像立刻进入了一个桃花源般的世界。如果只看每行最后的音节，就会发现这首诗似乎并没有明确的韵脚，但是如果以诵读的方式读这首诗，又会发现其中似乎隐藏着音乐性，并不会觉得拗口，每小行的分段恰到好处。以“面颊温暖”为例，温暖、羞惭本身就是对少女面颊的形容词，而作者在这首诗中将两个形容词拆开，放入了不同的位置。这种刻意地分离使诗歌又产生了新的意趣：“羞惭”是“低下头”回答着皇帝的原因，并且羞惭使“低下头”“回答”这个动作变得更连贯，也就是说，使诗歌的“语气”延续，贯通了下来；又比如说“一面镜子永远等候她/让她坐到镜中常坐的地方/望着窗外，只要想起一生中后悔的事”。“坐”和“望”是同时进行的两个动作，作者将这两个动作分别放入不同的行中，“望着窗外”后直接衔接想起的内容，如果只看这首诗的最后两句“望着窗外，只要想起一生中后悔的事/梅花便落满了南山”，就会发现这也是一个完整的动作，因此可以认为：镜中只是这件事发生的地点，这在很大程度上保证了“望”和“想”的独立性。诗题名为《镜中》，这给了读者一个潜在的导向，要求读者思考“镜子”这一意象的含义。而上述的分段又很好地平衡了人物与意象，动与静，活跃与沉默的统一，诗意便在叙述中荡漾。值得一提的是，这首诗同样被音乐人（如老狼，钟立风，程璧）谱曲形成了风格各异的音乐作品，在另一个维度上印证了诗歌的音律性。 在文章的最后感谢中华文化（文学篇）的期中作业让我能静下心来，以文字的方式梳理脑海中琐碎的片段，并简单地赏析一首自己很喜欢的诗歌。让我能有一个恰当的理由沉入诗歌的世界中，短暂地逃避繁重的课业。文学是一阵自由的风，风过无痕，但带来了清凉的一瞬。诗意地栖居对每一个现代人来说都是必要的，当进入到一首诗的世界中时，无论作何解读，只要能有所触动，就已经拥抱了诗意，读诗的人便成为了诗歌的一部分，诗歌也因阅读变得完整。 参考文献 [1] 王泽龙.新诗声音的变革与重构[J].华中师范大学学报(人文社会科学版)，2023，62(05) [2] 郭沫若:《论诗》，见郭沫若著、黄淳浩校:《文艺论集》(汇校本)，长沙:湖南人民出版社，1984年，第253页 [3] 沈浩波：什么是诗——从诗意到诗性，从意象到叙述","link":"/2025/12/01/%E8%AF%97%E4%B8%8E%E6%AD%8C%E2%80%94%E2%80%94%E4%BB%A5%E3%80%8A%E9%95%9C%E4%B8%AD%E3%80%8B%E4%B8%BA%E4%BE%8B%E6%B5%85%E8%B0%88%E8%AF%97%E6%AD%8C%E7%9A%84%E2%80%9C%E8%AF%AD%E6%B0%94%E2%80%9D/"}],"tags":[{"name":"网站开发","slug":"网站开发","link":"/tags/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"},{"name":"环境管理","slug":"环境管理","link":"/tags/%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/"},{"name":"诗歌评论","slug":"诗歌评论","link":"/tags/%E8%AF%97%E6%AD%8C%E8%AF%84%E8%AE%BA/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"其他计算机技术","slug":"其他计算机技术","link":"/categories/%E5%85%B6%E4%BB%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/"},{"name":"Maven","slug":"后端/Maven","link":"/categories/%E5%90%8E%E7%AB%AF/Maven/"},{"name":"Web基础","slug":"后端/Web基础","link":"/categories/%E5%90%8E%E7%AB%AF/Web%E5%9F%BA%E7%A1%80/"},{"name":"Ajax","slug":"前端/Ajax","link":"/categories/%E5%89%8D%E7%AB%AF/Ajax/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"现代诗","slug":"现代诗","link":"/categories/%E7%8E%B0%E4%BB%A3%E8%AF%97/"}],"pages":[{"title":"About Me","text":"我是 Wang Haotian，现就读于四川大学生物医学工程学院，修读医学信息工程专业。我的研究兴趣包括脑机接口、医学信息、机器学习等。此外，我对诗歌、小说和摇滚乐很感兴趣，欢迎和我交流！ I’m Wang Haotian, an undergraduate student majoring in Medical Information Engineering at the College of Biomedical Engineering, Sichuan University. My research interests include brain-computer interfaces, medical informatics, and machine learning. Additionally, I have a passion for poetry, fiction, and rock music. Feel free to reach out to me!","link":"/about/index.html"}]}